{"version":3,"sources":["../../../src/main/parser/parser.js"],"names":["Parser","input","lexer","Lexer","currentToken","nextToken","assignment","Assignment","identifier","expect","TokenType","Identifier","value","operator","parseExpression","acceptOperatorFunction","parseBranchFunction","expression","apply","binaryExpression","BinaryExpression","left","right","LeftBrace","block","Block","accept","RightBrace","expressions","push","parseBinaryExpression","acceptBooleanOperator","parseComparison","parseBooleanExpression","acceptCastOperator","As","cast","Cast","object","type","classToken","Class","klass","LeftParen","parameters","parseFormals","Extends","superClass","Types","Object","superClassArgs","parseActuals","parseClassBody","line","column","New","call","ConstructorCall","args","token","definition","parseClass","Override","Func","parseFunction","Error","Report","error","formals","RightParen","Comma","lazy","Lazy","nameToken","Colon","Formal","overrideToken","privateToken","override","isPrivate","Private","funcToken","func","Function","name","acceptOperator","returnType","Unit","Equal","body","FunctionCall","functionName","If","ifElse","IfElse","condition","thenBranch","Else","elseBranch","initializations","initialization","Initialization","Let","letExpr","parseInitializations","In","Null","NullLiteral","program","Program","EndOfInput","classes","varToken","Var","property","Property","Super","Dot","parseFunctionCall","SuperFunctionCall","This","While","whileExpr","parseCast","acceptComparisonOperator","parseAddition","acceptAdditiveOperator","parseMultiplication","acceptMultiplicativeOperator","parseDispatch","actuals","properties","parseProperty","functions","parseValue","Integer","IntegerLiteral","Decimal","DecimalLiteral","String","StringLiteral","parseNull","True","False","BooleanLiteral","parseIfElse","parseWhile","parseLet","parseBlock","parseConstructorCall","parseThis","parseSuperFunctionCall","acceptUnaryOperator","UnaryExpression","Not","Minus","lookahead","PlusEqual","MinusEqual","TimesEqual","DivEqual","ModuloEqual","parseAssignment","Reference","tokenType","Newline","discardNewlines","Token","acceptOtherOperator","acceptOneOf","Plus","Times","Div","Modulo","Less","LessOrEqual","Greater","GreaterOrEqual","DoubleEqual","NotEqual","And","Or","Tilde","Dollar","Caret","TildeEqual","DollarEqual","CaretEqual","tokenTypes","indexOf"],"mappings":"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","file":"parser.js","sourcesContent":["import { Assignment } from '../ast/assignment'\nimport { BinaryExpression } from '../ast/binaryexpression'\nimport { Block } from '../ast/block'\nimport { BooleanLiteral } from '../ast/boolean'\nimport { Cast } from '../ast/cast'\nimport { Class } from '../ast/class'\nimport { ConstructorCall } from '../ast/constructorcall'\nimport { DecimalLiteral } from '../ast/decimal'\nimport { Initialization } from '../ast/initialization'\nimport { Formal } from '../ast/formal'\nimport { IfElse } from '../ast/ifelse'\nimport { IntegerLiteral } from '../ast/integer'\nimport { Let } from '../ast/let'\nimport { Lexer } from '../lexer/lexer'\nimport { Function } from '../ast/func'\nimport { FunctionCall } from '../ast/functioncall'\nimport { NullLiteral } from '../ast/null'\nimport { Program } from '../ast/program'\nimport { Reference } from '../ast/reference'\nimport { Report } from '../util/report'\nimport { StringLiteral } from '../ast/string'\nimport { SuperFunctionCall } from '../ast/superfunctioncall'\nimport { This } from '../ast/this'\nimport { TokenType } from '../lexer/tokentype'\nimport { Token } from '../lexer/token'\nimport { Types } from '../types/types'\nimport { UnaryExpression } from '../ast/unaryexpression'\nimport { Property } from '../ast/property'\nimport { While } from '../ast/while'\n\nexport class Parser {\n\n    constructor(input) {\n        this.lexer = new Lexer(input);\n        this.currentToken = this.lexer.nextToken();\n    }\n\n    parseAssignment() {\n        let assignment = new Assignment();\n\n        assignment.identifier = this.expect(TokenType.Identifier).value;\n\n        assignment.operator = this.currentToken.value;\n\n        this.currentToken = this.lexer.nextToken();\n\n        assignment.value = this.parseExpression();\n\n        return assignment;\n    }\n\n    parseBinaryExpression(acceptOperatorFunction, parseBranchFunction) {\n        let expression = parseBranchFunction.apply(this);\n\n        if (acceptOperatorFunction.apply(this)) {\n\n            while (acceptOperatorFunction.apply(this)) {\n                let binaryExpression = new BinaryExpression();\n\n                binaryExpression.operator = this.currentToken.value\n\n                this.currentToken = this.lexer.nextToken();\n\n                binaryExpression.left = expression;\n\n                binaryExpression.right = parseBranchFunction.apply(this);\n\n                expression = binaryExpression;\n            }\n        }\n\n        return expression;\n    }\n\n    parseBlock() {\n        this.expect(TokenType.LeftBrace);\n\n        var block = new Block();\n\n        while (!this.accept(TokenType.RightBrace)) {\n            block.expressions.push(this.parseExpression());\n        }\n\n        this.expect(TokenType.RightBrace);\n\n        return block;\n    }\n\n    parseBooleanExpression() {\n        return this.parseBinaryExpression(this.acceptBooleanOperator, this.parseComparison);\n    }\n\n    parseCast() {\n        let expression = this.parseBooleanExpression();\n\n        if (this.acceptCastOperator()) {\n            while (this.acceptCastOperator()) {\n                this.expect(TokenType.As);\n\n                let cast = new Cast();\n\n                cast.object = expression;\n\n                cast.type = this.expect(TokenType.Identifier).value;\n\n                expression = cast;\n            }\n        }\n\n        return expression;\n    }\n\n    parseClass() {\n        let classToken = this.expect(TokenType.Class);\n\n        let klass = new Class(this.expect(TokenType.Identifier).value);\n\n        if (this.accept(TokenType.LeftParen)) {\n            klass.parameters = this.parseFormals();\n        }\n\n        if (!this.accept(TokenType.Extends)) {\n            klass.superClass = Types.Object;\n        } else {\n            this.expect(TokenType.Extends);\n\n            klass.superClass = this.expect(TokenType.Identifier).value;\n\n            if (this.accept(TokenType.LeftParen)) {\n                klass.superClassArgs = this.parseActuals();\n            }\n        }\n\n        this.parseClassBody(klass);\n\n        klass.line = classToken.line;\n        klass.column = classToken.column;\n\n        return klass;\n    }\n\n    parseConstructorCall() {\n        this.expect(TokenType.New);\n\n        let call = new ConstructorCall();\n\n        call.type = this.expect(TokenType.Identifier).value;\n\n        call.args = this.parseActuals();\n\n        return call;\n    }\n\n    parseDefinition() {\n        let token = this.currentToken;\n\n        let definition = null;\n\n        if (this.accept(TokenType.Class)) {\n            definition = this.parseClass();\n        }\n\n        if (this.accept(TokenType.Override) || this.accept(TokenType.Func)) {\n            definition = this.parseFunction();\n        }\n\n        if (definition === null) {\n            throw new Error(Report.error(token.type, token.column, `Unexpected '${token.type}'.`));\n        }\n\n        return definition;\n    }\n\n    parseFormals() {\n        this.expect(TokenType.LeftParen);\n\n        let formals = [];\n\n        if (!this.accept(TokenType.RightParen)) {\n            do {\n                if (this.accept(TokenType.Comma)) {\n                    this.expect(TokenType.Comma);\n                }\n\n                let lazy = false;\n\n                if (this.accept(TokenType.Lazy)) {\n                    this.expect(TokenType.Lazy);\n                    lazy = true;\n                }\n\n                let nameToken = this.expect(TokenType.Identifier);\n\n                this.expect(TokenType.Colon);\n\n                let type = this.expect(TokenType.Identifier).value;\n\n                formals.push(new Formal(nameToken.value, type, lazy, nameToken.line, nameToken.column));\n\n            } while (this.accept(TokenType.Comma));\n        }\n\n        this.expect(TokenType.RightParen);\n\n        return formals;\n    }\n\n    parseFunction() {\n        let overrideToken = null;\n        let privateToken = null;\n\n        let override = false;\n        let isPrivate = false;\n\n        if (this.accept(TokenType.Override)) {\n            overrideToken = this.expect(TokenType.Override);\n\n            override = true;\n        } else if (this.accept(TokenType.Private)) {\n            privateToken = this.expect(TokenType.Private);\n\n            isPrivate = true;\n        }\n\n        let funcToken = this.expect(TokenType.Func);\n\n        let func = new Function();\n\n        func.override = override;\n        func.isPrivate = isPrivate;\n        func.line = isPrivate ? privateToken.line : override ? overrideToken.line : funcToken.line;\n        func.column = isPrivate ? privateToken.column : override ? overrideToken.column : funcToken.column;\n\n        if (this.accept(TokenType.Identifier)) {\n            func.name = this.expect(TokenType.Identifier).value;\n\n        } else if (this.acceptOperator()) {\n            func.name = this.currentToken.value;\n\n            this.currentToken = this.lexer.nextToken();\n\n        } else {\n            throw new Error(Report.error(func.line, func.column, `Expected identifier or operator as method name, but found '${this.currentToken.value}'.`));\n        }\n\n        func.parameters = this.parseFormals();\n\n        if (!this.accept(TokenType.Colon)) {\n            func.returnType = Types.Unit;\n        } else {\n            this.expect(TokenType.Colon);\n\n            func.returnType = this.expect(TokenType.Identifier).value;\n        }\n\n        this.expect(TokenType.Equal);\n\n        func.body = this.parseExpression();\n\n        return func;\n    }\n\n    parseFunctionCall() {\n        let call = new FunctionCall();\n        let token = null;\n\n        if (this.accept(TokenType.Identifier)) {\n            token = this.expect(TokenType.Identifier);\n\n        } else {\n            token = this.currentToken;\n            this.currentToken = this.lexer.nextToken();\n        }\n\n        call.functionName = token.value;\n        call.line = token.line;\n        call.column = token.column;\n        call.args = this.parseActuals();\n\n        return call;\n    }\n\n    parseIfElse() {\n        this.expect(TokenType.If);\n\n        var ifElse = new IfElse();\n\n        this.expect(TokenType.LeftParen);\n\n        ifElse.condition = this.parseExpression();\n\n        this.expect(TokenType.RightParen);\n\n        ifElse.thenBranch = this.parseExpression();\n\n        if (this.accept(TokenType.Else)) {\n            this.expect(TokenType.Else);\n\n            ifElse.elseBranch = this.parseExpression();\n        }\n\n        return ifElse;\n    }\n\n    parseInitializations() {\n        let initializations = [];\n\n        do {\n\n            if (this.accept(TokenType.Comma)) {\n                this.expect(TokenType.Comma);\n            }\n\n            let initialization = new Initialization();\n\n            let token = this.expect(TokenType.Identifier);\n\n            initialization.identifier = token.value;\n\n            if (this.accept(TokenType.Colon)) {\n                this.expect(TokenType.Colon);\n\n                initialization.type = this.expect(TokenType.Identifier).value;\n            }\n\n            if (this.accept(TokenType.Equal)) {\n                this.expect(TokenType.Equal);\n\n                initialization.value = this.parseExpression();\n            }\n\n            initialization.line = token.line;\n            initialization.column = token.column;\n\n            initializations.push(initialization);\n\n        } while (this.accept(TokenType.Comma));\n\n        return initializations;\n    }\n\n    parseLet() {\n        this.expect(TokenType.Let);\n\n        var letExpr = new Let();\n\n        letExpr.initializations = this.parseInitializations();\n\n        this.expect(TokenType.In);\n\n        letExpr.body = this.parseExpression();\n\n        return letExpr;\n    }\n\n    parseNull() {\n        this.expect(TokenType.Null);\n\n        return new NullLiteral();\n    }\n\n    parseProgram() {\n        let program = new Program();\n\n        while (!this.accept(TokenType.EndOfInput)) {\n            program.classes.push(this.parseClass());\n        }\n\n        return program;\n    }\n\n    parseProperty() {\n        let varToken = this.expect(TokenType.Var);\n\n        let property = new Property();\n\n        property.name = this.expect(TokenType.Identifier).value;\n\n        if (this.accept(TokenType.Colon)) {\n            this.expect(TokenType.Colon);\n\n            property.type = this.expect(TokenType.Identifier).value;\n        }\n\n        if (this.accept(TokenType.Equal)) {\n            this.expect(TokenType.Equal);\n\n            property.value = this.parseExpression();\n        }\n\n        property.line = varToken.line;\n        property.column = varToken.column;\n\n        return property;\n    }\n\n    parseSuperFunctionCall() {\n        this.expect(TokenType.Super);\n\n        this.expect(TokenType.Dot);\n\n        let call = this.parseFunctionCall();\n\n        return new SuperFunctionCall(call.functionName, call.args);\n    }\n\n    parseThis() {\n        this.expect(TokenType.This);\n\n        return new This();\n    }\n\n    parseWhile() {\n        this.expect(TokenType.While);\n\n        var whileExpr = new While();\n\n        this.expect(TokenType.LeftParen);\n\n        whileExpr.condition = this.parseExpression();\n\n        this.expect(TokenType.RightParen);\n\n        whileExpr.body = this.parseExpression();\n\n        return whileExpr;\n    }\n\n    parseExpression() {\n        return this.parseCast();\n    }\n\n    parseComparison() {\n        return this.parseBinaryExpression(this.acceptComparisonOperator, this.parseAddition);\n    }\n\n    parseAddition() {\n        return this.parseBinaryExpression(this.acceptAdditiveOperator, this.parseMultiplication);\n    }\n\n    parseMultiplication() {\n        return this.parseBinaryExpression(this.acceptMultiplicativeOperator, this.parseDispatch);\n    }\n\n    parseActuals() {\n        this.expect(TokenType.LeftParen);\n\n        let actuals = [];\n\n        if (!this.accept(TokenType.RightParen)) {\n            do {\n                if (this.accept(TokenType.Comma)) {\n                    this.expect(TokenType.Comma);\n                }\n\n                actuals.push(this.parseExpression());\n\n            } while (this.accept(TokenType.Comma));\n        }\n\n        this.expect(TokenType.RightParen);\n\n        return actuals;\n    }\n\n    parseClassBody(klass) {\n        this.expect(TokenType.LeftBrace);\n\n        do {\n            if (this.accept(TokenType.RightBrace)) {\n                break;\n            }\n\n            if (this.accept(TokenType.Var)) {\n                klass.properties.push(this.parseProperty());\n\n            } else if (this.accept(TokenType.Func) || this.accept(TokenType.Private) || this.accept(TokenType.Override)) {\n                klass.functions.push(this.parseFunction());\n\n            } else if (this.accept(TokenType.EndOfInput)) {\n                throw new Error(Report.error(this.currentToken.line, this.currentToken.column, `Unexpected end of input.`));\n\n            } else {\n                throw new Error(Report.error(this.currentToken.line, this.currentToken.column, `Unexpected token '${this.currentToken.value}'.`));\n            }\n\n        } while (!this.accept(TokenType.RightBrace) && !this.accept(TokenType.EndOfInput));\n\n        this.expect(TokenType.RightBrace);\n    }\n\n    parseDispatch() {\n        let expression = this.parseValue();\n\n        while (this.accept(TokenType.Dot)) {\n            this.expect(TokenType.Dot);\n\n            let call = this.parseFunctionCall();\n\n            call.object = expression;\n\n            expression = call;\n        }\n\n        return expression;\n    }\n\n    parseValue() {\n        let token = this.currentToken;\n\n        if (this.accept(TokenType.EndOfInput)) {\n            throw new Error(Report.error(token.line, token.column, 'Unexpected end of input.'));\n        }\n\n        let value = null;\n\n        if (this.accept(TokenType.Integer)) {\n            value = new IntegerLiteral(this.expect(TokenType.Integer).value);\n\n        } else if (this.accept(TokenType.Decimal)) {\n            value = new DecimalLiteral(this.expect(TokenType.Decimal).value);\n\n        } else if (this.accept(TokenType.String)) {\n            value = new StringLiteral(this.expect(TokenType.String).value);\n\n        } else if (this.accept(TokenType.Null)) {\n            value = this.parseNull();\n\n        } else if (this.accept(TokenType.True) || this.accept(TokenType.False)) {\n            value = new BooleanLiteral(this.currentToken.value);\n\n            this.currentToken = this.lexer.nextToken();\n\n        } else if (this.accept(TokenType.If)) {\n            value = this.parseIfElse();\n\n        } else if (this.accept(TokenType.While)) {\n            value = this.parseWhile();\n\n        } else if (this.accept(TokenType.Let)) {\n            value = this.parseLet();\n\n        } else if (this.accept(TokenType.LeftBrace)) {\n            value = this.parseBlock();\n\n        } else if (this.accept(TokenType.New)) {\n            value = this.parseConstructorCall();\n\n        } else if (this.accept(TokenType.This)) {\n            value = this.parseThis();\n\n        } else if (this.accept(TokenType.Super)) {\n            value = this.parseSuperFunctionCall();\n\n        } else if (this.acceptUnaryOperator()) {\n            let operator = this.currentToken.value;\n\n            this.currentToken = this.lexer.nextToken();\n\n            value = new UnaryExpression(operator, this.parseValue());\n\n        } else if (this.accept(TokenType.Not)) {\n            value = new UnaryExpression(this.expect(TokenType.Not).value, this.parseExpression());\n\n        } else if (this.accept(TokenType.Minus)) {\n            value = new UnaryExpression(this.expect(TokenType.Minus).value, this.parseExpression());\n\n        } else if (this.accept(TokenType.LeftParen)) {\n            this.expect(TokenType.LeftParen);\n\n            value = this.parseExpression();\n\n            this.expect(TokenType.RightParen);\n\n        } else if (this.accept(TokenType.Identifier)) {\n            let lookahead = this.lexer.lookahead();\n\n            if (lookahead.type === TokenType.Equal || lookahead.type === TokenType.PlusEqual\n                || lookahead.type === TokenType.MinusEqual || lookahead.type === TokenType.TimesEqual\n                || lookahead.type === TokenType.DivEqual || lookahead.type === TokenType.ModuloEqual) {\n                value = this.parseAssignment();\n\n            } else if (lookahead.type === TokenType.LeftParen) {\n                value = this.parseFunctionCall();\n\n            } else {\n                value = new Reference(this.expect(TokenType.Identifier).value);\n            }\n        }\n\n        if (value === null) {\n            throw new Error(`Unexpected '${token.value}' at ${token.line + 1}:${token.column + 1}.`);\n        }\n\n        value.line = token.line;\n        value.column = token.column;\n\n        return value;\n    }\n\n    accept(tokenType) {\n        if (tokenType !== TokenType.Newline) {\n            this.discardNewlines();\n        }\n\n        if (tokenType !== TokenType.EndOfInput && this.currentToken.type === Token.EndOfInput) {\n            return false;\n        }\n\n        return this.currentToken.type === tokenType;\n    }\n\n    expect(tokenType) {\n        if (tokenType !== TokenType.Newline) {\n            this.discardNewlines();\n        }\n\n        let token = new Token(this.currentToken.type, this.currentToken.value, this.currentToken.line, this.currentToken.column);\n\n        if (tokenType !== TokenType.EndOfInput && token.type === TokenType.EndOfInput) {\n            throw new Error(Report.error(token.line, token.column, `Expected '${tokenType}' but reached end of input.`));\n        }\n\n        if (token.type !== tokenType) {\n            throw new Error(Report.error(token.line, token.column, `Expected '${tokenType}' but found '${token.value}'.`));\n        }\n\n        this.currentToken = this.lexer.nextToken();\n\n        return token;\n    }\n\n    acceptOperator() {\n        return this.acceptAdditiveOperator() || this.acceptComparisonOperator()\n            || this.acceptMultiplicativeOperator() || this.acceptBooleanOperator()\n            || this.acceptOtherOperator();\n    }\n\n    acceptCastOperator() {\n        return this.accept(TokenType.As);\n    }\n\n    acceptAdditiveOperator() {\n        return this.acceptOneOf(TokenType.Plus, TokenType.Minus);\n    }\n\n    acceptMultiplicativeOperator() {\n        return this.acceptOneOf(TokenType.Times, TokenType.Div, TokenType.Modulo);\n    }\n\n    acceptComparisonOperator() {\n        return this.acceptOneOf(TokenType.Less, TokenType.LessOrEqual, TokenType.Greater,\n            TokenType.GreaterOrEqual, TokenType.DoubleEqual, TokenType.NotEqual);\n    }\n\n    acceptBooleanOperator() {\n        return this.acceptOneOf(TokenType.And, TokenType.Or, TokenType.DoubleEqual, TokenType.NotEqual);\n    }\n\n    acceptAssignmentOperator() {\n        return this.acceptOneOf(TokenType.Equal, TokenType.PlusEqual, TokenType.MinusEqual,\n            TokenType.TimesEqual, TokenType.DivEqual, TokenType.ModuloEqual);\n    }\n\n    acceptUnaryOperator() {\n        return this.acceptOneOf(TokenType.Plus, TokenType.Minus, TokenType.Times,\n            TokenType.Div, TokenType.Modulo, TokenType.Tilde, TokenType.Dollar, TokenType.Caret);\n    }\n\n    acceptOtherOperator() {\n        return this.acceptOneOf(TokenType.Tilde, TokenType.TildeEqual, TokenType.Dollar,\n            TokenType.DollarEqual, TokenType.Caret, TokenType.CaretEqual);\n    }\n\n    acceptOneOf(...tokenTypes) {\n        if (tokenTypes.indexOf(TokenType.Newline) < 0) {\n            this.discardNewlines();\n        }\n\n        let type = this.currentToken.type;\n\n        if (type === TokenType.EndOfInput) {\n            return false;\n        }\n\n        return tokenTypes.indexOf(type) >= 0;\n    }\n\n    discardNewlines() {\n        while (this.currentToken.type === TokenType.Newline) {\n            this.currentToken = this.lexer.nextToken();\n        }\n    }\n}\n"]}