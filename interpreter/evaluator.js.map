{"version":3,"sources":["../../../src/main/interpreter/evaluator.js"],"names":["Evaluator","context","expression","undefined","isDefinition","Obj","create","Types","Unit","value","isAssignment","evaluateAssignment","isBinaryExpression","evaluateBinaryExpression","isBlock","evaluateBlock","isBooleanLiteral","evaluateBooleanLiteral","isCast","evaluateCast","isConstructorCall","evaluateConstructorCall","isDecimalLiteral","evaluateDecimalLiteral","isFunctionCall","evaluateFunctionCall","isIfElse","evaluateIfElse","isInitialization","evaluateInitialization","isIntegerLiteral","evaluateIntegerLiteral","isLet","evaluateLet","isNative","evaluateNative","isNullLiteral","evaluateNullLiteral","isReference","evaluateReference","isStringLiteral","evaluateStringLiteral","isSuper","evaluateSuperFunctionCall","isThis","evaluateThis","isUnaryExpression","evaluateUnaryExpression","isWhile","evaluateWhile","expressionType","type","assign","address","environment","find","identifier","operator","evaluate","FunctionCall","Reference","charAt","store","put","self","has","set","left","right","block","size","expressions","length","enterScope","i","exitScope","bool","Bool","cast","object","properties","forEach","v","k","call","evaluateConstructorImpl","args","decimal","Double","parseFloat","func","getMostSpecificFunction","functionName","map","arg","evaluateFunctionCallImpl","ifElse","condition","get","thenBranch","elseBranch","init","defaultValue","alloc","add","integer","Int","parseInt","letExpr","initializations","body","free","native","nullExpr","Null","property","reference","Expression","prop","string","String","substring","baseType","getClass","superClass","base","thisExpr","whileExpr","klass","argsValues","l","parameters","superClassArgs","variable","name","evaluateProperty","Error","Report","error","line","column","lazy","push","LazyExpression","copy","parameter"],"mappings":"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","file":"evaluator.js","sourcesContent":["import { ConstructorCall } from '../ast/constructorcall'\nimport { Expression } from '../ast/expression'\nimport { LazyExpression } from '../ast/lazyexpression'\nimport { FunctionCall } from '../ast/functioncall'\nimport { Obj } from './object'\nimport { Reference } from '../ast/reference'\nimport { Report } from '../util/report'\nimport { Types } from '../types/types'\n\nexport class Evaluator {\n\n    constructor() {\n    }\n\n    static evaluate(context, expression) {\n        if (expression === undefined || expression.isDefinition()) {\n            return Obj.create(context, Types.Unit);\n        }\n\n        let value = null;\n\n        if (expression.isAssignment()) {\n            value = this.evaluateAssignment(context, expression);\n\n        } else if (expression.isBinaryExpression()) {\n            value = this.evaluateBinaryExpression(context, expression);\n\n        } else if (expression.isBlock()) {\n            value = this.evaluateBlock(context, expression);\n\n        } else if (expression.isBooleanLiteral()) {\n            value = this.evaluateBooleanLiteral(context, expression);\n\n        } else if (expression.isCast()) {\n            value = this.evaluateCast(context, expression);\n\n        } else if (expression.isConstructorCall()) {\n            value = this.evaluateConstructorCall(context, expression);\n\n        } else if (expression.isDecimalLiteral()) {\n            value = this.evaluateDecimalLiteral(context, expression);\n\n        } else if (expression.isFunctionCall()) {\n            value = this.evaluateFunctionCall(context, expression);\n\n        } else if (expression.isIfElse()) {\n            value = this.evaluateIfElse(context, expression);\n\n        } else if (expression.isInitialization()) {\n            value = this.evaluateInitialization(context, expression);\n\n        } else if (expression.isIntegerLiteral()) {\n            value = this.evaluateIntegerLiteral(context, expression);\n\n        } else if (expression.isLet()) {\n            value = this.evaluateLet(context, expression);\n\n        } else if (expression.isNative()) {\n            value = this.evaluateNative(context, expression);\n\n        } else if (expression.isNullLiteral()) {\n            value = this.evaluateNullLiteral(context, expression);\n\n        } else if (expression.isReference()) {\n            value = this.evaluateReference(context, expression);\n\n        } else if (expression.isStringLiteral()) {\n            value = this.evaluateStringLiteral(context, expression);\n\n        } else if (expression.isSuper()) {\n            value = this.evaluateSuperFunctionCall(context, expression);\n\n        } else if (expression.isThis()) {\n            value = this.evaluateThis(context, expression);\n\n        } else if (expression.isUnaryExpression()) {\n            value = this.evaluateUnaryExpression(context, expression);\n\n        } else if (expression.isWhile()) {\n            value = this.evaluateWhile(context, expression);\n\n        }\n\n        expression.expressionType = value.type;\n\n        return value;\n    }\n\n    static evaluateAssignment(context, assign) {\n        let address = context.environment.find(assign.identifier);\n\n        let value = assign.operator === '='\n            ? this.evaluate(context, assign.value)\n            : this.evaluateFunctionCall(context, new FunctionCall(new Reference(assign.identifier), assign.operator.charAt(0), [assign.value]));\n\n        if (address !== undefined) {\n            context.store.put(address, value);\n\n        } else if (context.self.has(assign.identifier)) {\n            context.self.set(assign.identifier, value);\n        }\n\n        return Obj.create(context, Types.Unit);\n    }\n\n    static evaluateBinaryExpression(context, expression) {\n        return this.evaluateFunctionCall(context, new FunctionCall(expression.left, expression.operator, [expression.right]));\n    }\n\n    static evaluateBlock(context, block) {\n        let size = block.expressions.length;\n\n        if (size == 0) {\n            return Obj.create(context, Types.Unit);\n        }\n\n        context.environment.enterScope();\n\n        for (let i = 0; i < size - 1; ++i) {\n            this.evaluate(context, block.expressions[i]);\n        }\n\n        let value = this.evaluate(context, block.expressions[size - 1]);\n\n        context.environment.exitScope();\n\n        return value;\n    }\n\n    static evaluateBooleanLiteral(context, bool) {\n        let value = Obj.create(context, Types.Bool);\n\n        value.set('value', bool.value === 'true');\n\n        return value;\n    }\n\n    static evaluateCast(context, cast) {\n        let object = this.evaluate(context, cast.object);\n\n        let value = Obj.create(context, cast.type);\n\n        object.properties.forEach((v, k) => {\n            value.set(k, v);\n        });\n\n        return value;\n    }\n\n    static evaluateConstructorCall(context, call) {\n        let object = Obj.create(context, call.type);\n\n        this.evaluateConstructorImpl(context, object, object.type, call.args);\n\n        return object;\n    }\n\n    static evaluateDecimalLiteral(context, decimal) {\n        let value = Obj.create(context, Types.Double);\n\n        value.set('value', parseFloat(decimal.value));\n\n        return value;\n    }\n\n    static evaluateFunctionCall(context, call) {\n        let object = call.object === undefined ? context.self\n            : this.evaluate(context, call.object);\n\n        let func = object.getMostSpecificFunction(call.functionName, call.args.map((arg) => arg.expressionType), context);\n\n        return this.evaluateFunctionCallImpl(context, object, func, call);\n    }\n\n    static evaluateIfElse(context, ifElse) {\n        let condition = this.evaluate(context, ifElse.condition);\n\n        return condition.get('value')\n            ? this.evaluate(context, ifElse.thenBranch)\n            : this.evaluate(context, ifElse.elseBranch);\n    }\n\n    static evaluateInitialization(context, init) {\n        let value = init.value !== undefined ? this.evaluate(context, init.value)\n                                             : Obj.defaultValue(context, init.type);\n\n        let address = context.store.alloc(value);\n\n        context.environment.add(init.identifier, address);\n    }\n\n    static evaluateIntegerLiteral(context, integer) {\n        let value = Obj.create(context, Types.Int);\n\n        value.set('value', parseInt(integer.value));\n\n        return value;\n    }\n\n    static evaluateLet(context, letExpr) {\n        letExpr.initializations.forEach((init) => {\n            this.evaluateInitialization(context, init);\n        });\n\n        let value = this.evaluate(context, letExpr.body);\n\n        letExpr.initializations.forEach((init) => {\n            context.store.free(context.environment.find(init.identifier));\n        });\n\n        return value;\n    }\n\n    static evaluateNative(context, native) {\n        return native.func(context);\n    }\n\n    static evaluateNullLiteral(context, nullExpr) {\n        return Obj.create(context, Types.Null);\n    }\n\n    static evaluateProperty(context, property) {\n        if (property.value === undefined) {\n            return Obj.defaultValue(context, property.type);\n        }\n\n        return this.evaluate(context, property.value);\n    }\n\n    static evaluateReference(context, reference) {\n        let address = context.environment.find(reference.identifier);\n\n        if (address !== undefined) {\n            let value = context.store.get(address);\n\n            if (value instanceof Expression) {\n                value = this.evaluate(context, value);\n\n                context.store.put(address, value);\n            }\n\n            return value;\n        }\n\n        let prop = context.self.get(reference.identifier);\n\n        if (prop instanceof Expression) {\n            prop = this.evaluate(context, prop);\n\n            context.self.set(reference.identifier, prop);\n        }\n\n        return prop;\n    }\n\n    static evaluateStringLiteral(context, string) {\n        let value = Obj.create(context, Types.String);\n\n        value.set('value', string.value.substring(1, string.value.length - 1));\n\n        return value;\n    }\n\n    static evaluateSuperFunctionCall(context, call) {\n        let baseType = context.getClass(context.self.type).superClass;\n\n        let base = Obj.create(context, baseType);\n\n        let func = base.getMostSpecificFunction(call.functionName, call.args.map((arg) => arg.expressionType), context);\n\n        return this.evaluateFunctionCallImpl(context, context.self, func, call);\n    }\n\n    static evaluateThis(context, thisExpr) {\n        return context.self;\n    }\n\n    static evaluateUnaryExpression(context, expression) {\n        return this.evaluateFunctionCall(context, new FunctionCall(expression.expression, 'unary_' + expression.operator, []));\n    }\n\n    static evaluateWhile(context, whileExpr) {\n        while (this.evaluate(context, whileExpr.condition).get('value') === true) {\n            this.evaluate(context, whileExpr.body);\n        }\n\n        return Obj.create(context, Types.Unit);\n    }\n\n    static evaluateConstructorImpl(context, object, type, args) {\n        let klass = context.getClass(type);\n\n        let argsValues = args.map((arg) => this.evaluate(context, arg));\n\n        let self = context.self;\n        context.self = object;\n\n        for (let i = 0, l = klass.parameters.length; i < l; ++i) {\n            object.set(klass.parameters[i].identifier, argsValues[i]);\n        }\n\n        if (klass.superClass !== undefined) {\n            this.evaluateConstructorImpl(context, object, klass.superClass, klass.superClassArgs);\n        }\n\n        klass.properties.forEach((variable) => {\n            object.set(variable.name, this.evaluateProperty(context, variable));\n        });\n\n        context.self = self;\n    }\n\n    static evaluateFunctionCallImpl(context, object, func, call) {\n        if (func === undefined) {\n            throw new Error(Report.error(call.line, call.column, `No function '${call.functionName}' defined in class '${object.type}'.`));\n        }\n\n        context.environment.enterScope();\n\n        let argsValues = [];\n\n        for (let i = 0, l = func.parameters.length; i < l; ++i) {\n            if (func.parameters[i].lazy) {\n                argsValues.push(new LazyExpression(call.args[i], context.copy()));\n\n            } else {\n                argsValues.push(this.evaluate(context, call.args[i]));\n            }\n        }\n\n        for (let i = 0, l = func.parameters.length; i < l; ++i) {\n            context.environment.add(func.parameters[i].identifier, context.store.alloc(argsValues[i]));\n        }\n\n        let self = context.self;\n\n        context.self = object;\n\n        let value = this.evaluate(context, func.body);\n\n        func.parameters.forEach((parameter) => {\n            context.store.free(context.environment.find(parameter.identifier));\n        });\n\n        context.environment.exitScope();\n\n        context.self = self;\n\n        return value;\n    }\n}"]}