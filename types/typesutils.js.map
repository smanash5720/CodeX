{"version":3,"sources":["../../../src/main/types/typesutils.js"],"names":["TypesUtils","typeA","typeB","env","Types","Null","classA","getClass","classB","superClass","inheritanceIndex","Object","leastUpperBound","index","undefined","klass","name","argsTypes","methods","findMethods","length","filter","method","allConform","parameters","map","param","type","reduce","curr","prev","mostSpecificFunction","i","l","equals","collect","cls","functions","forEach","override","splice","push","superClassName","overridingMethod","find","funcA","funcB","paramsTypesA","paramsTypesB","typesA","typesB","conform","isPrimitive","methodName","hasFunctionWithName","Int","Double","Bool","Unit"],"mappings":"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","file":"typesutils.js","sourcesContent":["import { Types } from './types'\n\nexport class TypesUtils {\n\n    static leastUpperBound(typeA, typeB, env) {\n        if (typeA === typeB) {\n            return typeA;\n        }\n\n        if (typeA === Types.Null) {\n            return typeB;\n        }\n\n        if (typeB === Types.Null) {\n            return typeA;\n        }\n\n        let classA = env.getClass(typeA);\n        let classB = env.getClass(typeB);\n\n        if (classA.superClass === classB.superClass) {\n            return classA.superClass;\n        }\n\n        if (this.inheritanceIndex(typeA, Types.Object, env) > this.inheritanceIndex(typeB, Types.Object, env)) {\n            return this.leastUpperBound(classA.superClass, typeB, env);\n        }\n\n        return this.leastUpperBound(typeA, classB.superClass, env);\n    }\n\n    static inheritanceIndex(typeA, typeB, env) {\n        let index = 0;\n\n        while (typeA !== undefined && typeA !== typeB) {\n            index++;\n\n            typeA = env.getClass(typeA).superClass;\n        }\n\n        return index;\n    }\n\n    static findMethodToApply(klass, name, argsTypes, env) {\n        let methods = this.findMethods(klass, name, argsTypes, env);\n\n        if (methods.length === 0) {\n            return undefined;\n        }\n\n        methods = methods.filter((method) => this.allConform(\n            argsTypes, method.parameters.map((param) => param.type), env\n        ));\n\n        if (methods.length === 0) {\n            return undefined;\n        }\n\n        return methods.reduce((curr, prev) => this.mostSpecificFunction(curr, prev, env));\n    }\n\n    static findMethods(klass, name, argsTypes, env) {\n        let methods = [];\n\n        let index = (method) => {\n            for (let i = 0, l = methods.length; i < l; ++i) {\n                if (methods[i].equals(method)) {\n                    return i;\n                }\n\n                return -1;\n            }\n        };\n\n        let collect = (cls) => {\n            if (cls.superClass !== undefined) {\n                collect(env.getClass(cls.superClass));\n            }\n\n            cls.functions\n                .filter((method) => method.name === name && method.parameters.length === argsTypes.length)\n                .forEach((method) => {\n                    let i = index(method);\n\n                    if (i !== -1 && method.override) {\n                        methods.splice(i, 1);\n                    }\n\n                    methods.push(method);\n                });\n        };\n\n        collect(klass);\n\n        return methods;\n    }\n\n    static findOverridedFunction(superClassName, overridingMethod, env) {\n        if (superClassName === undefined) {\n            return undefined;\n        }\n\n        let klass = env.getClass(superClassName);\n\n        do {\n            let method = klass.functions.find((method) => method.equals(overridingMethod));\n\n            if (method !== undefined) {\n                return method;\n            }\n\n            if (klass.superClass === undefined) {\n                break;\n            }\n\n            klass = env.getClass(superClass.superClass);\n\n        } while (klass.superClass !== undefined);\n\n        return undefined;\n    }\n\n    static mostSpecificFunction(funcA, funcB, env) {\n        if (funcA === undefined || funcB === undefined) {\n            return undefined;\n        }\n\n        let paramsTypesA = funcA.parameters.map((param) => param.type);\n        let paramsTypesB = funcB.parameters.map((param) => param.type);\n\n        if (this.allConform(paramsTypesA, paramsTypesB, env)) {\n            return funcA;\n        }\n\n        if (this.allConform(paramsTypesB, paramsTypesA, env)) {\n            return funcB;\n        }\n\n        return undefined;\n    }\n\n    static allConform(typesA, typesB, env) {\n        let length = typesA.length;\n\n        if (typesB.length !== length) {\n            return false;\n        }\n\n        for (let i = 0, l = typesA.length; i < l; ++i) {\n            if (!this.conform(typesA[i], typesB[i], env)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    static allEqual(typesA, typesB) {\n        let length = typesA.length;\n\n        if (typesB.length !== length) {\n            return false;\n        }\n\n        for (let i = 0; i < length; ++i) {\n            if (typesA[i] !== typesB[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    static conform(typeA, typeB, env) {\n        if (typeB === Types.Object) {\n            return true;\n        }\n\n        if (typeA === typeB) {\n            return true;\n        }\n\n        if (!this.isPrimitive(typeB) && typeA === Types.Null) {\n            return true;\n        }\n\n        let classA = env.getClass(typeA);\n        let classB = env.getClass(typeB);\n\n        do {\n            if (classA.superClass === classB.name) {\n                return true;\n            }\n\n            if (classB.superClass === undefined) {\n                return false;\n            }\n\n            classB = env.getClass(classB.superClass);\n\n        } while (classB.name !== Types.Object);\n\n        return false;\n    }\n\n    static hasFunctionWithName(klass, methodName, env) {\n        while (klass !== undefined) {\n            if (klass.hasFunctionWithName(methodName)) {\n                return true;\n            }\n\n            klass = env.getClass(klass.superClass);\n        }\n\n        return false;\n    }\n\n    static isPrimitive(type) {\n        return type === Types.Int || type === Types.Double\n            || type === Types.Bool || type === Types.Unit;\n    }\n\n    static isInternal(type) {\n        return type === 'int' || type === 'double' || type === 'bool' || type === 'string';\n    }\n}"]}