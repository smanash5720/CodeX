{"version":3,"sources":["../../../src/test/interpreter/evaluator-test.js"],"names":["assert","describe","typeEnv","TypeEnvironment","context","Context","before","boolClass","BoolClass","doubleClass","DoubleClass","objectClass","ObjectClass","intClass","IntClass","stringClass","StringClass","unitClass","UnitClass","addClass","beforeEach","symbolTable","clear","it","source","expression","Parser","parseExpression","TypeChecker","typeCheck","value","Evaluator","evaluate","equal","get","type","fractionClassSource","fractionClass","parseClass","typeCheckClass","has","environment","enterScope","exitScope"],"mappings":"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","file":"evaluator-test.js","sourcesContent":["import * as assert from 'assert'\nimport { Class } from '../../main/ast/class'\nimport { Context } from '../../main/interpreter/context'\nimport { Evaluator } from '../../main/interpreter/evaluator'\nimport { BoolClass } from '../../main/interpreter/std/bool'\nimport { DoubleClass } from '../../main/interpreter/std/double'\nimport { IntClass } from '../../main/interpreter/std/int'\nimport { ObjectClass } from '../../main/interpreter/std/object'\nimport { Parser } from '../../main/parser/parser'\nimport { StringClass } from '../../main/interpreter/std/str'\nimport { TypeChecker } from '../../main/semanticanalysis/typechecker'\nimport { TypeEnvironment } from '../../main/semanticanalysis/typeenvironment'\nimport { UnitClass } from '../../main/interpreter/std/unit'\n\ndescribe('Evaluator', () => {\n\n   describe('#evaluate', () => {\n\n       let typeEnv = new TypeEnvironment();\n       let context = new Context();\n\n       before(() => {\n           let boolClass = new BoolClass();\n           let doubleClass = new DoubleClass();\n           let objectClass = new ObjectClass();\n           let intClass = new IntClass();\n           let stringClass = new StringClass();\n           let unitClass = new UnitClass();\n\n           typeEnv.addClass(boolClass);\n           typeEnv.addClass(doubleClass);\n           typeEnv.addClass(objectClass);\n           typeEnv.addClass(intClass);\n           typeEnv.addClass(stringClass);\n           typeEnv.addClass(unitClass);\n\n           context.addClass(boolClass);\n           context.addClass(doubleClass);\n           context.addClass(objectClass);\n           context.addClass(intClass);\n           context.addClass(stringClass);\n           context.addClass(unitClass);\n       });\n\n       beforeEach(() => {\n           typeEnv.symbolTable.clear();\n       });\n\n       it('should evaluate a boolean literal', () => {\n           let source = 'false';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           let value = Evaluator.evaluate(context, expression);\n\n           assert.equal(false, value.get('value'));\n       });\n\n       it('should evaluate an integer literal', () => {\n           let source = '42';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           let value = Evaluator.evaluate(context, expression);\n\n           assert.equal(42, value.get('value'));\n       });\n\n       it('should evaluate a decimal literal', () => {\n           let source = '3.14';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           let value = Evaluator.evaluate(context, expression);\n\n           assert.equal(3.14, value.get('value'));\n       });\n\n       it('should evaluate a string literal', () => {\n           let source = '\"Hello, world!\"';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           let value = Evaluator.evaluate(context, expression);\n\n           assert.equal('Hello, world!', value.get('value'));\n       });\n\n       it('should evaluate string concatenation', () => {\n           let source = '\"Hello\" + \" world!\"';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           let value = Evaluator.evaluate(context, expression);\n\n           assert.equal('Hello world!', value.get('value'));\n       });\n\n       it('should evaluate an integer addition', () => {\n           let source = '1 + 2 + 3 + 4 + 5';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           let value = Evaluator.evaluate(context, expression);\n\n           assert.equal(15, value.get('value'));\n       });\n\n       it('should evaluate an if/else expression', () => {\n           let source = 'if (2 < 3) { 42 } else { 21 }';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           let value = Evaluator.evaluate(context, expression);\n\n           assert.equal('Int', value.type);\n           assert.equal(42, value.get('value'));\n       });\n\n       it('should evaluate a constructor call', () => {\n           let fractionClassSource =\n               'class Fraction(n: Int, d: Int) {\\n' +\n                    'var num: Int = n\\n' +\n                    'var den: Int = d\\n' +\n               '}';\n\n           let fractionClass = (new Parser(fractionClassSource)).parseClass();\n\n           typeEnv.addClass(fractionClass);\n           context.addClass(fractionClass);\n\n           TypeChecker.typeCheckClass(typeEnv, fractionClass);\n\n           let source = 'new Fraction(3, 4)';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           let value = Evaluator.evaluate(context, expression);\n\n           assert.equal('Fraction', value.type);\n\n           assert.equal(true, value.has('num'));\n           assert.equal(true, value.has('den'));\n\n           assert.equal(3, value.get('num').get('value'));\n           assert.equal(4, value.get('den').get('value'));\n       });\n\n       it('should evaluate a simple method call', () => {\n           let fractionClassSource =\n               'class Fraction(n: Int, d: Int) {\\n' +\n                    'var num: Int = n\\n' +\n                    'var den: Int = d\\n' +\n                    '' +\n                    'override func toString(): String = num.toString() + \"/\" + den.toString()\\n' +\n               '}';\n\n           let fractionClass = (new Parser(fractionClassSource)).parseClass();\n\n           typeEnv.addClass(fractionClass);\n           context.addClass(fractionClass);\n\n           TypeChecker.typeCheckClass(typeEnv, fractionClass);\n\n           let source = 'let f = new Fraction(3, 4) in f.toString()';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           context.environment.enterScope();\n\n           let value = Evaluator.evaluate(context, expression);\n\n           context.environment.exitScope();\n\n           assert.equal('3/4', value.get('value'));\n       });\n\n       it('should evaluate a reference', () => {\n           let source = 'let n = 42 in n';\n\n           let expression = (new Parser(source)).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           context.environment.enterScope();\n\n           let value = Evaluator.evaluate(context, expression);\n\n           context.environment.exitScope();\n\n           assert.equal(42, value.get('value'));\n       });\n\n       it('should evaluate a while expression', () => {\n           let source =\n               'let counter = 0 in {\\n' +\n                    'while (counter < 10) {\\n' +\n                        'counter = counter + 1\\n' +\n                    '}\\n' +\n                    'counter\\n' +\n               '}';\n\n           let expression = new Parser(source).parseExpression();\n\n           TypeChecker.typeCheck(typeEnv, expression);\n\n           context.environment.enterScope();\n\n           let value = Evaluator.evaluate(context, expression);\n\n           context.environment.exitScope();\n\n           assert.equal(10, value.get('value'));\n       });\n   });\n});"]}