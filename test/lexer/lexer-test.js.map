{"version":3,"sources":["../../../src/test/lexer/lexer-test.js"],"names":["assert","describe","it","lexer","Lexer","token","nextToken","equal","type","TokenType","Newline","value","Integer","Decimal","String","True","False","Identifier","Abstract","Class","Func","Else","Extends","Final","For","In","If","Let","New","Null","Override","Private","Protected","Return","Super","To","This","Var","While","Dot","LeftArrow","DivEqual","Equal","MinusEqual","ModuloEqual","PlusEqual","RightArrow","TimesEqual","Div","Modulo","Minus","Plus","Times","DoubleEqual","Greater","GreaterOrEqual","Less","LessOrEqual","NotEqual","And","Not","Or","Colon","Comma","LeftBrace","RightBrace","LeftBracket","RightBracket","LeftParen","RightParen","tokens","tokenize","length","line","column"],"mappings":"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","file":"lexer-test.js","sourcesContent":["import * as assert from 'assert'\nimport { TokenType } from '../../main/lexer/tokentype'\nimport { Lexer } from '../../main/lexer/lexer'\n\ndescribe('Lexer', () => {\n\n    describe('#nextToken', () => {\n\n        it('should recognize a newline character as a single token', () => {\n            var lexer = new Lexer('\\n');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Newline);\n            assert.equal(token.value, '\\n');\n        });\n\n        it('should recognize the number 0', () => {\n            var lexer = new Lexer('0');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Integer);\n            assert.equal(token.value, '0');\n        });\n\n        it('should recognize a simple integer literal', () => {\n            var lexer = new Lexer('42');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Integer);\n            assert.equal(token.value, '42');\n        });\n\n        it('should recognize a simple decimal literal', () => {\n            var lexer = new Lexer('3.14');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Decimal);\n            assert.equal(token.value, '3.14');\n        });\n\n        it('should recognize a decimal starting with dot (.)', () => {\n            var lexer = new Lexer('.25');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Decimal);\n            assert.equal(token.value, '.25');\n        });\n\n        it('should recognize a decimal in scientific notation', () => {\n            var lexer = new Lexer('2e65');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Decimal);\n            assert.equal(token.value, '2e65');\n        });\n\n        it('should recognize a decimal in scientific notation with negative exponent part', () => {\n            var lexer = new Lexer('42e-65');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Decimal);\n            assert.equal(token.value, '42e-65');\n        });\n\n        it('should recognize a simple string literal', () => {\n            var lexer = new Lexer('\"Hello, World!\"');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.String);\n            assert.equal(token.value, '\"Hello, World!\"');\n        });\n\n        it('should recognize a string containing a newline character', () => {\n            var lexer = new Lexer('\"a string containing a \\\\n newline character.\"');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.String);\n            assert.equal(token.value, '\"a string containing a \\\\n newline character.\"');\n        });\n\n        it('should recognize a string containing an espaced backslash', () => {\n            var lexer = new Lexer('\"a string with a \\\\\\\\ backslash\"');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.String);\n            assert.equal(token.value, '\"a string with a \\\\\\\\ backslash\"');\n        });\n\n        it('should recognize a string containing escaped double quotes', () => {\n            var lexer = new Lexer('\"a string containing an \\\\\" escaped double quote\"');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.String);\n            assert.equal(token.value, '\"a string containing an \\\\\" escaped double quote\"');\n        });\n\n        it('should recognize a string containing escape sequences', () => {\n            var lexer = new Lexer('\"a string containing \\\\t\\\\b\\\\r\\\\f\\\\v\\\\0 escape sequences\"');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.String);\n            assert.equal(token.value, '\"a string containing \\\\t\\\\b\\\\r\\\\f\\\\v\\\\0 escape sequences\"');\n        });\n\n        it('should recognize the boolean true literal', () => {\n            var lexer = new Lexer('true');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.True);\n            assert.equal(token.value, 'true');\n        });\n\n        it('should recognize the boolean false literal', () => {\n            var lexer = new Lexer('false');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.False);\n            assert.equal(token.value, 'false');\n        });\n\n        it('should recognize an identifier of a single letter', () => {\n            var lexer = new Lexer('i');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Identifier);\n            assert.equal(token.value, 'i');\n        });\n\n        it('should recognize an identifier made of letters', () => {\n            var lexer = new Lexer('anIdentifier');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Identifier);\n            assert.equal(token.value, 'anIdentifier');\n        });\n\n        it('should recognize an identifier starting with underscore (_)', () => {\n            var lexer = new Lexer('_identifier');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Identifier);\n            assert.equal(token.value, '_identifier');\n        });\n\n        it('should recognize an identifier containing an underscore (_)', () => {\n            var lexer = new Lexer('an_identifier');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Identifier);\n            assert.equal(token.value, 'an_identifier');\n        });\n\n        it('should recognize an identifier containing a $ character', () => {\n            var lexer = new Lexer('an$identifier');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Identifier);\n            assert.equal(token.value, 'an$identifier');\n        });\n\n        it('should recognize an identifier containing a digit', () => {\n            var lexer = new Lexer('identifier1');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Identifier);\n            assert.equal(token.value, 'identifier1');\n        });\n\n        it('should recognize the abstract keyword', () => {\n            var lexer = new Lexer('abstract');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Abstract);\n            assert.equal(token.value, 'abstract');\n        });\n\n        it('should recognize the class keyword', () => {\n            var lexer = new Lexer('class');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Class);\n            assert.equal(token.value, 'class');\n        });\n\n        it('should recognize the func keyword', () => {\n            var lexer = new Lexer('func');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Func);\n            assert.equal(token.value, 'func');\n        });\n\n        it('should recognize the else keyword', () => {\n            var lexer = new Lexer('else');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Else);\n            assert.equal(token.value, 'else');\n        });\n\n        it('should recognize the extends keyword', () => {\n            var lexer = new Lexer('extends');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Extends);\n            assert.equal(token.value, 'extends');\n        });\n\n        it('should recognize the false keyword', () => {\n            var lexer = new Lexer('false');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.False);\n            assert.equal(token.value, 'false');\n        });\n\n        it('should recognize the final keyword', () => {\n            var lexer = new Lexer('final');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Final);\n            assert.equal(token.value, 'final');\n        });\n\n        it('should recognize the for keyword', () => {\n            var lexer = new Lexer('for');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.For);\n            assert.equal(token.value, 'for');\n        });\n\n        it('should recognize the in keyword', () => {\n            var lexer = new Lexer('in');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.In);\n            assert.equal(token.value, 'in');\n        });\n\n        it('should recognize the if keyword', () => {\n            var lexer = new Lexer('if');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.If);\n            assert.equal(token.value, 'if');\n        });\n\n        it('should recognize the let keyword', () => {\n            var lexer = new Lexer('let');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Let);\n            assert.equal(token.value, 'let');\n        });\n\n        it('should recognize the new keyword', () => {\n            var lexer = new Lexer('new');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.New);\n            assert.equal(token.value, 'new');\n        });\n\n        it('should recognize the null keyword', () => {\n            var lexer = new Lexer('null');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Null);\n            assert.equal(token.value, 'null');\n        });\n\n        it('should recognize the override keyword', () => {\n            var lexer = new Lexer('override');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Override);\n            assert.equal(token.value, 'override');\n        });\n\n        it('should recognize the private keyword', () => {\n            var lexer = new Lexer('private');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Private);\n            assert.equal(token.value, 'private');\n        });\n\n        it('should recognize the protected keyword', () => {\n            var lexer = new Lexer('protected');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Protected);\n            assert.equal(token.value, 'protected');\n        });\n\n        it('should recognize the return keyword', () => {\n            var lexer = new Lexer('return');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Return);\n            assert.equal(token.value, 'return');\n        });\n\n        it('should recognize the super keyword', () => {\n            var lexer = new Lexer('super');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Super);\n            assert.equal(token.value, 'super');\n        });\n\n        it('should recognize the to keyword', () => {\n            var lexer = new Lexer('to');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.To);\n            assert.equal(token.value, 'to');\n        });\n\n        it('should recognize the this keyword', () => {\n            var lexer = new Lexer('this');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.This);\n            assert.equal(token.value, 'this');\n        });\n\n        it('should recognize the true keyword', () => {\n            var lexer = new Lexer('true');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.True);\n            assert.equal(token.value, 'true');\n        });\n\n        it('should recognize the var keyword', () => {\n            var lexer = new Lexer('var');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Var);\n            assert.equal(token.value, 'var');\n        });\n\n        it('should recognize the while keyword', () => {\n            var lexer = new Lexer('while');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.While);\n            assert.equal(token.value, 'while');\n        });\n\n        it('should recognize an identifier starting with a reserved keyword', () => {\n            var lexer = new Lexer('toString');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Identifier);\n            assert.equal(token.value, 'toString');\n        });\n\n        it('should recognize the dispatch (.) operator', () => {\n            var lexer = new Lexer('.');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Dot);\n            assert.equal(token.value, '.');\n        });\n\n        it('should recognize the left arrow (<-) operator', () => {\n            var lexer = new Lexer('<-');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.LeftArrow);\n            assert.equal(token.value, '<-');\n        });\n\n        it('should recognize the div-equal (/=) operator', () => {\n            var lexer = new Lexer('/=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.DivEqual);\n            assert.equal(token.value, '/=');\n        });\n\n        it('should recognize the equal (=) operator', () => {\n            var lexer = new Lexer('=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Equal);\n            assert.equal(token.value, '=');\n        });\n\n        it('should recognize the minus-equal (-=) operator', () => {\n            var lexer = new Lexer('-=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.MinusEqual);\n            assert.equal(token.value, '-=');\n        });\n\n        it('should recognize the modulo-equal (%=) operator', () => {\n            var lexer = new Lexer('%=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.ModuloEqual);\n            assert.equal(token.value, '%=');\n        });\n\n        it('should recognize the plus-equal (+=) operator', () => {\n            var lexer = new Lexer('+=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.PlusEqual);\n            assert.equal(token.value, '+=');\n        });\n\n        it('should recognize the right arrow (->) operator', () => {\n            var lexer = new Lexer('->');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.RightArrow);\n            assert.equal(token.value, '->');\n        });\n\n        it('should recognize the times-equal operator', () => {\n            var lexer = new Lexer('*=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.TimesEqual);\n            assert.equal(token.value, '*=');\n        });\n\n        it('should recognize the div (/) operator', () => {\n            var lexer = new Lexer('/');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Div);\n            assert.equal(token.value, '/');\n        });\n\n        it('should recognize the modulo (%) operator', () => {\n            var lexer = new Lexer('%');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Modulo);\n            assert.equal(token.value, '%');\n        });\n\n        it('should recognize the minus (-) operator', () => {\n            var lexer = new Lexer('-');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Minus);\n            assert.equal(token.value, '-');\n        });\n\n        it('should recognize the plus (+) operator', () => {\n            var lexer = new Lexer('+');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Plus);\n            assert.equal(token.value, '+');\n        });\n\n        it('should recognize the times (*) operator', () => {\n            var lexer = new Lexer('*');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Times);\n            assert.equal(token.value, '*');\n        });\n\n        it('should recognize the double-equal (==) operator', () => {\n            var lexer = new Lexer('==');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.DoubleEqual);\n            assert.equal(token.value, '==');\n        });\n\n        it('should recognize the greater (>) operator', () => {\n            var lexer = new Lexer('>');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Greater);\n            assert.equal(token.value, '>');\n        });\n\n        it('should recognize the greater-or-equal (>=) operator', () => {\n            var lexer = new Lexer('>=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.GreaterOrEqual);\n            assert.equal(token.value, '>=');\n        });\n\n        it('should recognize the less (<) operator', () => {\n            var lexer = new Lexer('<');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Less);\n            assert.equal(token.value, '<');\n        });\n\n        it('should recognize the less-or-equal operator', () => {\n            var lexer = new Lexer('<=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.LessOrEqual);\n            assert.equal(token.value, '<=');\n        });\n\n        it('should recognize the not-equal (!=) operator', () => {\n            var lexer = new Lexer('!=');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.NotEqual);\n            assert.equal(token.value, '!=');\n        });\n\n        it('should recognize the and (&&) operator', () => {\n            var lexer = new Lexer('&&');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.And);\n            assert.equal(token.value, '&&');\n        });\n\n        it('should recognize the not (!) operator', () => {\n            var lexer = new Lexer('!');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Not);\n            assert.equal(token.value, '!');\n        });\n\n        it('should recognize the or (||) operator', () => {\n            var lexer = new Lexer('||');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Or);\n            assert.equal(token.value, '||');\n        });\n\n        it('should recognize a colon (:)', () => {\n            var lexer = new Lexer(':');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Colon);\n            assert.equal(token.value, ':');\n        });\n\n        it('should recognize a comma (,)', () => {\n            var lexer = new Lexer(',');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Comma);\n            assert.equal(token.value, ',');\n        });\n\n        it('should recognize a left brace ({)', () => {\n            var lexer = new Lexer('{');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.LeftBrace);\n            assert.equal(token.value, '{');\n        });\n\n        it('should recognize a right brace (})', () => {\n            var lexer = new Lexer('}');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.RightBrace);\n            assert.equal(token.value, '}');\n        });\n\n        it('should recognize a left bracket ([)', () => {\n            var lexer = new Lexer('[');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.LeftBracket);\n            assert.equal(token.value, '[');\n        });\n\n        it('should recognize a right bracket (])', () => {\n            var lexer = new Lexer(']');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.RightBracket);\n            assert.equal(token.value, ']');\n        });\n\n        it('should recognize a left parenthesis (()', () => {\n            var lexer = new Lexer('(');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.LeftParen);\n            assert.equal(token.value, '(');\n        });\n\n        it('should recognize a right parenthesis ())', () => {\n            var lexer = new Lexer(')');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.RightParen);\n            assert.equal(token.value, ')');\n        });\n\n        it('should recognize a colon (:)', () => {\n            var lexer = new Lexer(':');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Colon);\n            assert.equal(token.value, ':');\n        });\n\n        it('should recognize a comma (,)', () => {\n            var lexer = new Lexer(',');\n\n            var token = lexer.nextToken();\n\n            assert.equal(token.type, TokenType.Comma);\n            assert.equal(token.value, ',');\n        });\n\n    });\n\n    describe('#tokenize', () => {\n\n        it('should properly tokenize a full method definition', () => {\n            var lexer = new Lexer('func add(a: Int, b: Int): Int = {\\n' +\n                '   a + b\\n' +\n                '}');\n\n            var tokens = lexer.tokenize();\n\n            assert.equal(21, tokens.length);\n\n            assert.equal(tokens[0].type, TokenType.Func);\n\n            assert.equal(tokens[1].type, TokenType.Identifier);\n            assert.equal(tokens[1].value, 'add');\n\n            assert.equal(tokens[2].type, TokenType.LeftParen);\n\n            assert.equal(tokens[3].type, TokenType.Identifier);\n            assert.equal(tokens[3].value, 'a');\n\n            assert.equal(tokens[4].type, TokenType.Colon);\n\n            assert.equal(tokens[5].type, TokenType.Identifier);\n            assert.equal(tokens[5].value, 'Int');\n\n            assert.equal(tokens[6].type, TokenType.Comma);\n\n            assert.equal(tokens[7].type, TokenType.Identifier);\n            assert.equal(tokens[7].value, 'b');\n\n            assert.equal(tokens[8].type, TokenType.Colon);\n\n            assert.equal(tokens[9].type, TokenType.Identifier);\n            assert.equal(tokens[9].value, 'Int');\n\n            assert.equal(tokens[10].type, TokenType.RightParen);\n\n            assert.equal(tokens[11].type, TokenType.Colon);\n\n            assert.equal(tokens[12].type, TokenType.Identifier);\n            assert.equal(tokens[12].value, 'Int');\n\n            assert.equal(tokens[13].type, TokenType.Equal);\n\n            assert.equal(tokens[14].type, TokenType.LeftBrace);\n\n            assert.equal(tokens[15].type, TokenType.Newline);\n\n            assert.equal(tokens[16].type, TokenType.Identifier);\n            assert.equal(tokens[16].value, 'a');\n\n            assert.equal(tokens[17].type, TokenType.Plus);\n\n            assert.equal(tokens[18].type, TokenType.Identifier);\n            assert.equal(tokens[18].value, 'b');\n\n            assert.equal(tokens[19].type, TokenType.Newline);\n\n            assert.equal(tokens[20].type, TokenType.RightBrace);\n        });\n\n        it('should assign the correct line and column numbers', () => {\n            var lexer = new Lexer('func equals(a: Int, b: Int): Boolean = {\\n' +\n                '   a == b\\n' +\n                '}');\n\n            var tokens = lexer.tokenize();\n\n            assert.equal(0, tokens[0].line);\n            assert.equal(0, tokens[0].column);\n\n            assert.equal(0, tokens[1].line);\n            assert.equal(5, tokens[1].column);\n\n            assert.equal(0, tokens[2].line);\n            assert.equal(11, tokens[2].column);\n\n            assert.equal(0, tokens[3].line);\n            assert.equal(12, tokens[3].column);\n\n            assert.equal(0, tokens[4].line);\n            assert.equal(13, tokens[4].column);\n\n            assert.equal(0, tokens[5].line);\n            assert.equal(15, tokens[5].column);\n\n            assert.equal(0, tokens[6].line);\n            assert.equal(18, tokens[6].column);\n\n            assert.equal(0, tokens[7].line);\n            assert.equal(20, tokens[7].column);\n\n            assert.equal(0, tokens[8].line);\n            assert.equal(21, tokens[8].column);\n\n            assert.equal(0, tokens[9].line);\n            assert.equal(23, tokens[9].column);\n\n            assert.equal(0, tokens[10].line);\n            assert.equal(26, tokens[10].column);\n\n            assert.equal(0, tokens[11].line);\n            assert.equal(27, tokens[11].column);\n\n            assert.equal(0, tokens[12].line);\n            assert.equal(29, tokens[12].column);\n\n            assert.equal(0, tokens[13].line);\n            assert.equal(37, tokens[13].column);\n\n            assert.equal(0, tokens[14].line);\n            assert.equal(39, tokens[14].column);\n\n            assert.equal(0, tokens[15].line);\n            assert.equal(40, tokens[15].column);\n\n            assert.equal(1, tokens[16].line);\n            assert.equal(3, tokens[16].column);\n\n            assert.equal(1, tokens[17].line);\n            assert.equal(5, tokens[17].column);\n\n            assert.equal(1, tokens[18].line);\n            assert.equal(8, tokens[18].column);\n\n            assert.equal(1, tokens[19].line);\n            assert.equal(9, tokens[19].column);\n\n            assert.equal(2, tokens[20].line);\n            assert.equal(0, tokens[20].column);\n        });\n\n        it('should tokenize a simple expression', () => {\n            var lexer = new Lexer('42 + 21');\n\n            var tokens = lexer.tokenize();\n\n            assert.equal(3, tokens.length);\n\n            assert.equal(tokens[0].type, TokenType.Integer);\n            assert.equal(tokens[0].value, '42');\n\n            assert.equal(tokens[1].type, TokenType.Plus);\n            assert.equal(tokens[1].value, '+');\n\n            assert.equal(tokens[2].type, TokenType.Integer);\n            assert.equal(tokens[2].value, '21');\n        });\n    });\n});"]}