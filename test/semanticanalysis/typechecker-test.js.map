{"version":3,"sources":["../../../src/test/semanticanalysis/typechecker-test.js"],"names":["assert","describe","it","parser","Parser","env","TypeEnvironment","addClass","Class","throws","TypeChecker","typeCheck","parseExpression","Error","expression","init","initializations","equal","type","expressionType","parseFunction","parseClass","ifElse","thenBranch","elseBranch","Types","Int","Unit","whileExpr"],"mappings":"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","file":"typechecker-test.js","sourcesContent":["import * as assert from 'assert'\nimport { Class } from '../../main/ast/class'\nimport { TypeEnvironment } from '../../main/semanticanalysis/typeenvironment'\nimport { Parser } from '../../main/parser/parser'\nimport { TypeChecker } from '../../main/semanticanalysis/typechecker'\nimport { Types } from '../../main/types/types'\n\ndescribe('TypeChecker', () => {\n\n    describe('#typeCheck', () => {\n        it('should throw an error if trying to assign to value of a different type than the one declared', () => {\n           let parser = new Parser(\n               'let x: Int in x = \"Hello\"'\n           );\n\n           let env = new TypeEnvironment();\n           env.addClass(new Class('Object'));\n           env.addClass(new Class('Int', [], 'Object'));\n           env.addClass(new Class('String', [], 'String'));\n\n           assert.throws(() => {\n               TypeChecker.typeCheck(env, parser.parseExpression());\n           }, Error, \"Cannot assign value of type 'String' to variable 'x' declared with type 'Int'.\");\n\n        });\n\n        it('should throw an error if trying to assign to a non declared variable', () => {\n            let parser = new Parser(\n                'let x: Int in y = 42'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n\n            assert.throws(() => {\n                TypeChecker.typeCheck(env, parser.parseExpression())\n            }, Error, `1:15: Assignment to an undefined variable 'y'.`);\n        });\n\n        it('should throw an error if trying to reference to a non declared variable', () => {\n            let parser = new Parser(\n                'let x: Double in y + x'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Double', [], 'Object'));\n\n            assert.throws(() => {\n                TypeChecker.typeCheck(env, parser.parseExpression())\n            }, Error, `1:18: Reference to an undefined identifier 'y'.`);\n        });\n\n        it('should infer the type of a variable during initialization if the type is not specified', () => {\n            let parser = new Parser('let x = 42 in x');\n\n            let expression = parser.parseExpression();\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n\n            TypeChecker.typeCheck(env, expression);\n\n            let init = expression.initializations[0];\n\n            assert.equal('Int', init.type);\n            assert.equal('Int', init.expressionType);\n        });\n\n        it('should not throw an error if the assignment is valid', () => {\n            let parser = new Parser(\n                'let x: Int in x = 42'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n            env.addClass(new Class('String', [], 'Object'));\n\n            TypeChecker.typeCheck(env, parser.parseExpression());\n        });\n\n        it('should throw an error if there are 2 variables with the same name in a let binding', () => {\n            let parser = new Parser(\n                'let x: Int = 42, x: Double = 3.14 in x + y'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n            env.addClass(new Class('Double', [], 'Object'));\n\n            assert.throws(() => {\n                TypeChecker.typeCheck(env, parser.parseExpression())\n            }, Error, `1:18: Duplicate identifier 'x' in let binding.`);\n        });\n\n        it('should throw an error if a function has 2 parameters of the same name', () => {\n            let parser = new Parser(\n                'func add(x: Int, x: Double): Double = {' +\n                    'x + x' +\n                '}'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n            env.addClass(new Class('String', [], 'Object'));\n\n            assert.throws(() => {\n                TypeChecker.typeCheck(env, parser.parseFunction())\n            }, Error, `1:17: Duplicate parameter name 'x' in function 'add'.`);\n        });\n\n        it('should throw an error if a class has 2 parameters of the same name', () => {\n            let parser = new Parser(\n                'class Complex(x: Int, x: Int) {' +\n                    'var a: Int = x' +\n                    '\\n' +\n                    'var b: Int = x' +\n                    '\\n' +\n                    'func toString(): String = a + \"+\" + b + \"i\"' +\n                '}'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n\n            assert.throws(() => {\n                TypeChecker.typeCheck(env, parser.parseClass())\n            }, Error, `1:23: Duplicate class parameter name 'x' in class 'Complex' definition.`);\n        });\n\n        it('should throw an error if a class has 2 instance variables of the same name', () => {\n            let parser = new Parser(\n                'class Complex(x: Int, y: Int) {' +\n                    'var a: Int = x' +\n                    '\\n' +\n                    'var a: Int = y' +\n                    '\\n' +\n                    'def toString(): String = \"a complex\"' +\n                    '\\n' +\n                ''\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n\n            assert.throws(() => {\n                TypeChecker.typeCheck(env, parser.parseClass())\n            }, Error, `2:1: An instance variable named 'a' is already in scope.`);\n        });\n\n        it('should throw an error if the condition of an if/else does not evaluate to a boolean value', () => {\n            let parser = new Parser(\n                'if (42) true else false'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n\n            assert.throws(() => {\n                TypeChecker.typeCheck(env, parser.parseExpression())\n            }, Error, `1:5: Condition of the if/else expression evaluates to a value of type 'Int', must evaluate to a boolean value.`);\n        });\n\n        it('should throw an error if the condition of a while expression does not evaluate to a boolean value', () => {\n            let parser = new Parser(\n                'while (\"hello\") true'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('String', [], 'Object'));\n\n            assert.throws(() => {\n                TypeChecker.typeCheck(env, parser.parseExpression())\n            }, Error, `1:8: Condition of a while loop evaluates to a value of type 'String', must evaluate to a boolean value.`);\n        });\n\n        it('should set the type of an if/else expression to the LUB of its 2 branches', () => {\n            let parser = new Parser(\n                'if (true) new Bretzel() else new Cat()'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Bool', [], 'Object'));\n            env.addClass(new Class('Animal', [], 'Object'));\n            env.addClass(new Class('Dog', [], 'Animal'));\n            env.addClass(new Class('Cat', [], 'Animal'));\n            env.addClass(new Class('Bretzel', [], 'Dog'));\n\n            let ifElse = parser.parseExpression();\n\n            TypeChecker.typeCheck(env, ifElse);\n\n            assert.equal('Bretzel', ifElse.thenBranch.expressionType);\n            assert.equal('Cat', ifElse.elseBranch.expressionType);\n            assert.equal('Animal', ifElse.expressionType);\n        });\n\n        it('should set the type of an if/else expression to Unit if the else branch is missing', () => {\n            let parser = new Parser(\n                'if (true) 42'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Bool', [], 'Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n\n            let ifElse = parser.parseExpression();\n\n            TypeChecker.typeCheck(env, ifElse);\n\n            assert.equal(Types.Int, ifElse.thenBranch.expressionType);\n            assert.equal(Types.Unit, ifElse.expressionType);\n        });\n\n        it('should set the type of a while expression to Unit', () => {\n            let parser = new Parser(\n                'while (true) 42'\n            );\n\n            let env = new TypeEnvironment();\n            env.addClass(new Class('Object'));\n            env.addClass(new Class('Bool', [], 'Object'));\n            env.addClass(new Class('Int', [], 'Object'));\n\n            let whileExpr = parser.parseExpression();\n\n            TypeChecker.typeCheck(env, whileExpr);\n\n            assert.equal(Types.Unit, whileExpr.expressionType);\n        });\n    });\n\n});"]}