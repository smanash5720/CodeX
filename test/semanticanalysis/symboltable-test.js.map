{"version":3,"sources":["../../../src/test/semanticanalysis/symboltable-test.js"],"names":["assert","describe","it","table","SymbolTable","enterScope","add","Symbol","equal","check","symbol","find","identifier","type","undefined","exitScope"],"mappings":"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","file":"symboltable-test.js","sourcesContent":["import * as assert from 'assert'\nimport { Symbol } from '../../main/semanticanalysis/symbol'\nimport { SymbolTable } from '../../main/semanticanalysis/symboltable'\n\ndescribe('SymbolTable', () => {\n\n    describe('#check', () => {\n\n        it('should return true if the identifier is declared in the current scope', () => {\n            let table = new SymbolTable();\n\n            table.enterScope();\n\n            table.add(new Symbol('x', 'Int'));\n\n            assert.equal(true, table.check('x'));\n        });\n\n        it('should return false if the identifier is not declared in the current scope but in an enclosing scope', () => {\n            let table = new SymbolTable();\n\n            table.enterScope();\n\n            table.add(new Symbol('x', 'Int'));\n\n            table.enterScope();\n\n            assert.equal(false, table.check('x'));\n        });\n\n        it('should return false if the identifier is not declared at all', () => {\n            let table = new SymbolTable();\n\n            table.enterScope();\n\n            assert.equal(false, table.check('x'));\n        });\n    });\n\n    describe('#find', () => {\n\n        it('should return the identifier declared in the most closest scope', () => {\n            let table = new SymbolTable();\n\n            table.enterScope();\n\n            table.add(new Symbol('x', 'Int'));\n\n            table.enterScope();\n\n            table.add(new Symbol('x', 'String'));\n\n            let symbol = table.find('x');\n\n            assert.equal('x', symbol.identifier);\n            assert.equal('String', symbol.type);\n        });\n\n        it('should return the identifier declared in the enclosing scope if the identifier is not available in the current scope', () => {\n            let table = new SymbolTable();\n\n            table.enterScope();\n\n            table.add(new Symbol('x', 'Int'));\n\n            table.enterScope();\n\n            let symbol = table.find('x');\n\n            assert.equal('x', symbol.identifier);\n            assert.equal('Int', symbol.type);\n        });\n\n        it('should return undefined for an identifier that has not been declared', () => {\n            let table = new SymbolTable();\n\n            table.enterScope();\n\n            let symbol = table.find('x');\n\n            assert.equal(undefined, symbol);\n        });\n    });\n\n    describe('#enterScope', () => {\n\n        it('should create a new nested scope', () => {\n            let table = new SymbolTable();\n\n            table.enterScope();\n\n            table.add(new Symbol('x', 'Int'));\n\n            table.enterScope();\n\n            assert.equal(false, table.check('x'));\n        });\n\n        //it('should enter the next enclosed scope', () => {\n        //    let table = new SymbolTable();\n        //\n        //    table.enterScope();\n        //\n        //    table.enterScope();\n        //\n        //    table.add(new Symbol('x', 'Int'));\n        //\n        //    assert.equal(true, table.check('x'));\n        //\n        //    table.exitScope();\n        //\n        //    assert.equal(false, table.check('x'));\n        //\n        //    table.enterScope();\n        //\n        //    assert.equal(true, table.check('x'));\n        //});\n    });\n\n    describe('#exitScope', () => {\n\n        it('should go back to the enclosing scope', () => {\n            let table = new SymbolTable();\n\n            table.enterScope();\n\n            table.add(new Symbol('x', 'Int'));\n\n            table.enterScope();\n\n            assert.equal(false, table.check('x'));\n\n            table.exitScope();\n\n            assert.equal(true, table.check('x'));\n        });\n    });\n\n});"]}