{"version":3,"sources":["../../../src/main/semanticanalysis/typechecker.js"],"names":["TypeChecker","environment","ast","undefined","isDefinition","isClass","typeCheckClass","isFunction","typeCheckFunction","isProperty","typeCheckProperty","isExpression","isAssignment","typeCheckAssignment","isBinaryExpression","typeCheckBinaryExpression","isBlock","typeCheckBlock","isBooleanLiteral","typeCheckBooleanLiteral","isCast","typeCheckCast","isConstructorCall","typeCheckConstructorCall","isDecimalLiteral","typeCheckDecimalLiteral","isIfElse","typeCheckIfElse","isInitialization","typeCheckInitialization","isIntegerLiteral","typeCheckIntegerLiteral","isLet","typeCheckLet","isFunctionCall","typeCheckFunctionCall","isNullLiteral","typeCheckNullLiteral","isReference","typeCheckReference","isStringLiteral","typeCheckStringLiteral","isSuper","typeCheckSuperFunctionCall","isThis","typeCheckThis","isUnaryExpression","typeCheckUnaryExpression","isWhile","typeCheckWhile","assign","symbol","symbolTable","find","identifier","Error","Report","error","line","column","typeCheck","value","valueType","expressionType","type","TypesUtils","conform","Types","Unit","expression","functionCall","FunctionCall","left","operator","right","block","enterScope","expressions","forEach","length","exitScope","boolean","Bool","cast","object","klass","currentClass","parameters","parameter","check","name","add","Symbol","superClass","ConstructorCall","superClassArgs","properties","property","functions","func","hasFunction","signature","addFunction","call","hasClass","getClass","parametersCount","args","i","arg","argType","parameterType","decimal","Double","override","overrided","findOverridedFunction","body","returnType","objectClass","hasFunctionWithName","functionName","argsTypes","map","findMethodToApply","join","isPrivate","ifElse","condition","thenBranch","elseBranch","leastUpperBound","init","integer","Int","letExpr","initializations","nullExpr","Null","program","classes","addClass","reference","hasProperty","getProperty","string","String","superCall","thisExpr","funcCall","whileExpr"],"mappings":"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","file":"typechecker.js","sourcesContent":["import { ConstructorCall } from '../ast/constructorcall'\nimport { FunctionCall } from '../ast/functioncall'\nimport { Report } from '../util/report'\nimport { Symbol } from './symbol'\nimport { Types } from '../types/types'\nimport { TypesUtils } from '../types/typesutils'\n\nexport class TypeChecker {\n\n    constructor() {\n    }\n\n    static typeCheck(environment, ast) {\n        if (ast === undefined) {\n            return;\n        }\n\n        if (ast.isDefinition()) {\n            if (ast.isClass()) {\n                this.typeCheckClass(environment, ast);\n\n            }  else if (ast.isFunction()) {\n                this.typeCheckFunction(environment, ast);\n\n            } else if (ast.isProperty()) {\n                this.typeCheckProperty(environment, ast);\n            }\n\n        } else if (ast.isExpression()) {\n            if (ast.isAssignment()) {\n                this.typeCheckAssignment(environment, ast);\n\n            } else if (ast.isBinaryExpression()) {\n                this.typeCheckBinaryExpression(environment, ast);\n\n            } else if (ast.isBlock()) {\n                this.typeCheckBlock(environment, ast);\n\n            } else if (ast.isBooleanLiteral()) {\n                this.typeCheckBooleanLiteral(environment, ast);\n\n            } else if (ast.isCast()) {\n                this.typeCheckCast(environment, ast);\n\n            } else if (ast.isConstructorCall()) {\n                this.typeCheckConstructorCall(environment, ast);\n\n            }else if (ast.isDecimalLiteral()) {\n                this.typeCheckDecimalLiteral(environment, ast);\n\n            } else if (ast.isIfElse()) {\n                this.typeCheckIfElse(environment, ast);\n\n            } else if (ast.isInitialization()) {\n                this.typeCheckInitialization(environment, ast);\n\n            } else if (ast.isIntegerLiteral()) {\n                this.typeCheckIntegerLiteral(environment, ast);\n\n            } else if (ast.isLet()) {\n                this.typeCheckLet(environment, ast);\n\n            } else if (ast.isFunctionCall()) {\n                this.typeCheckFunctionCall(environment, ast);\n\n            } else if (ast.isNullLiteral()) {\n                this.typeCheckNullLiteral(environment, ast);\n\n            } else if (ast.isReference()) {\n                this.typeCheckReference(environment, ast);\n\n            } else if (ast.isStringLiteral()) {\n                this.typeCheckStringLiteral(environment, ast);\n\n            } else if (ast.isSuper()) {\n                this.typeCheckSuperFunctionCall(environment, ast);\n\n            } else if (ast.isThis()) {\n                this.typeCheckThis(environment, ast);\n\n            } else if (ast.isUnaryExpression()) {\n                this.typeCheckUnaryExpression(environment, ast);\n\n            } else if (ast.isWhile()) {\n                this.typeCheckWhile(environment, ast);\n            }\n        }\n    }\n\n    static typeCheckAssignment(environment, assign) {\n        let symbol = environment.symbolTable.find(assign.identifier);\n\n        if (symbol === undefined) {\n            throw new Error(Report.error(assign.line, assign.column, `Assignment to an undefined variable '${assign.identifier}'.`));\n        }\n\n        this.typeCheck(environment, assign.value);\n\n        let valueType = assign.value.expressionType;\n\n        if (symbol.type === undefined) {\n            symbol.type = valueType;\n\n        } else if (!TypesUtils.conform(valueType, symbol.type, environment)) {\n            throw new Error(`Value assigned to '${symbol.identifier}' does not conform to the declared type '${symbol.type}'.`);\n        }\n\n        assign.expressionType = Types.Unit;\n    }\n\n    static typeCheckBinaryExpression(environment, expression) {\n        let functionCall = new FunctionCall(expression.left, expression.operator, [expression.right]);\n\n        functionCall.line = expression.line;\n        functionCall.column = expression.column;\n\n        this.typeCheckFunctionCall(environment, functionCall);\n\n        expression.expressionType = functionCall.expressionType;\n    }\n\n    static typeCheckBlock(environment, block) {\n        environment.symbolTable.enterScope();\n\n        block.expressions.forEach((expression) => {\n            this.typeCheck(environment, expression);\n        });\n\n        let length = block.expressions.length;\n\n        block.expressionType = length > 0 ? block.expressions[length - 1].expressionType : Types.Unit;\n\n        environment.symbolTable.exitScope();\n    }\n\n    static typeCheckBooleanLiteral(environment, boolean) {\n        boolean.expressionType = Types.Bool;\n    }\n\n    static typeCheckCast(environment, cast) {\n        this.typeCheck(environment, cast.object);\n\n        if (!TypesUtils.conform(cast.type, cast.object.expressionType, environment)) {\n            throw new Error(Report.error(cast.line, cast.column, `Cannot cast an object of type '${cast.object.expressionType}' to '${cast.type}'.`));\n        }\n\n        cast.expressionType = cast.type;\n    }\n\n    static typeCheckClass(environment, klass) {\n        let symbolTable = environment.symbolTable;\n\n        let currentClass = environment.currentClass;\n\n        environment.currentClass = klass;\n\n        symbolTable.enterScope();\n\n        klass.parameters.forEach((parameter) => {\n            if (symbolTable.check(parameter.identifier)) {\n                throw new Error(Report.error(parameter.line, parameter.column, `Duplicate class parameter name '${parameter.identifier}' in class '${klass.name}' definition.`));\n            }\n\n            symbolTable.add(new Symbol(parameter.identifier, parameter.type, parameter.line, parameter.column));\n        });\n\n        if (klass.superClass !== undefined) {\n            this.typeCheckConstructorCall(environment, new ConstructorCall(klass.superClass, klass.superClassArgs));\n        }\n\n        klass.properties.forEach((property) => {\n            this.typeCheckProperty(environment, property);\n        });\n\n        klass.functions.forEach((func) => {\n            if (environment.hasFunction(klass.name, func)) {\n                throw new Error(Report.error(func.line, func.column, `Function '${func.name}' with signature '${func.signature()}' is already defined in class '${klass.name}'.`));\n            }\n\n            environment.addFunction(klass.name, func);\n\n            this.typeCheckFunction(environment, func);\n        });\n\n        symbolTable.exitScope();\n\n        environment.currentClass = currentClass;\n    }\n\n    static typeCheckConstructorCall(environment, call) {\n        if (!environment.hasClass(call.type)) {\n            throw new Error(Report.error(call.line, call.column, `Undefined type '${call.type}'.`));\n        }\n\n        let klass = environment.getClass(call.type);\n\n        let parametersCount = klass.parameters.length;\n\n        if (parametersCount !== call.args.length) {\n            throw new Error(Report.error(call.line, call.column, `Class '${klass.name}' constructor called with wrong number of arguments.`));\n        }\n\n        for (let i = 0; i < parametersCount; ++i) {\n            let arg = call.args[i];\n\n            this.typeCheck(environment, arg);\n\n            let argType = arg.expressionType;\n            let parameterType = klass.parameters[i].type;\n\n            if (!TypesUtils.conform(argType, parameterType, environment)) {\n                throw new Error(Report.error(arg.line, arg.column, `Class '${klass.name}' constructor argument type '${argType}' does not conform to declared type '${parameterType}'.`));\n            }\n        }\n\n        call.expressionType = call.type;\n    }\n\n    static typeCheckDecimalLiteral(environment, decimal) {\n        decimal.expressionType = Types.Double;\n    }\n\n    static typeCheckFunction(environment, func) {\n        let symbolTable = environment.symbolTable;\n\n        if (func.override) {\n            let overrided = TypesUtils.findOverridedFunction(environment.currentClass.superClass, func, environment);\n\n            if (overrided === undefined) {\n                throw new Error(Report.error(func.line, func.column, `No suitable function '${func.signature()}' found in superclass(es) to override.`));\n            }\n        }\n\n        symbolTable.enterScope();\n\n        func.parameters.forEach((parameter) => {\n            if (symbolTable.check(parameter.identifier)) {\n                throw new Error(Report.error(parameter.line, parameter.column, `Duplicate parameter name '${parameter.identifier}' in func '${func.name}'.`));\n            }\n\n            symbolTable.add(new Symbol(parameter.identifier, parameter.type, parameter.line, parameter.column));\n        });\n\n        this.typeCheck(environment, func.body);\n\n        if (!TypesUtils.conform(func.body.expressionType, func.returnType, environment)) {\n            throw new Error(Report.error(func.line, func.column, `Function '${func.name}' value type '${func.body.expressionType}' does not conform to return type '${func.returnType}'.`));\n        }\n\n        symbolTable.exitScope();\n    }\n\n    static typeCheckFunctionCall(environment, call) {\n        if (call.object !== undefined) {\n            this.typeCheck(environment, call.object);\n        }\n\n        let objectClass = call.object === undefined ? environment.currentClass\n            : environment.getClass(call.object.expressionType);\n\n        if (!TypesUtils.hasFunctionWithName(objectClass, call.functionName, environment)) {\n            throw new Error(Report.error(call.line, call.column, `No function '${call.functionName}' defined in class '${objectClass.name}'.`));\n        }\n\n        call.args.forEach((arg) => {\n            this.typeCheck(environment, arg);\n        });\n\n        let argsTypes = call.args.map((arg) => arg.expressionType);\n\n        let func = TypesUtils.findMethodToApply(objectClass, call.functionName, argsTypes, environment);\n\n        if (func === undefined) {\n            throw new Error(Report.error(call.line, call.column, `Function '${call.functionName}' of class '${objectClass.name}' cannot be applied to '(${argsTypes.join(\",\")})'.`));\n        }\n\n        if (func.isPrivate && !(call.object === undefined ||call.object.isThis())) {\n            throw new Error(Report.error(call.line, call.column, `Function '${call.functionName}' of class '${objectClass.name}' is private.`));\n        }\n\n        call.expressionType = func.returnType;\n    }\n\n    static typeCheckIfElse(environment, ifElse) {\n        this.typeCheck(environment, ifElse.condition);\n\n        if (ifElse.condition.expressionType !== Types.Bool) {\n            throw new Error(Report.error(ifElse.condition.line, ifElse.condition.column, `Condition of the if/else expression evaluates to a value of type '${ifElse.condition.expressionType}', must evaluate to a boolean value.`));\n        }\n\n        this.typeCheck(environment, ifElse.thenBranch);\n\n        if (ifElse.elseBranch === undefined) {\n            ifElse.expressionType = Types.Unit;\n\n        } else {\n            this.typeCheck(environment, ifElse.elseBranch);\n\n            ifElse.expressionType = TypesUtils.leastUpperBound(ifElse.thenBranch.expressionType, ifElse.elseBranch.expressionType, environment);\n        }\n    }\n\n    static typeCheckInitialization(environment, init) {\n        let symbolTable = environment.symbolTable;\n\n        if (symbolTable.check(init.identifier)) {\n            throw new Error(Report.error(init.line, init.column, `Duplicate identifier '${init.identifier}' in let binding.`));\n        }\n\n        let symbol = new Symbol(init.identifier, init.type, init.line, init.column);\n\n        if (init.value === undefined) {\n            init.expressionType = init.type;\n\n        } else {\n            this.typeCheck(environment, init.value);\n\n            let valueType = init.value.expressionType;\n\n            if (init.type === undefined) {\n                init.type = valueType;\n\n            } else {\n                if (!TypesUtils.conform(valueType, init.type, environment)) {\n                    throw new Error(Report.error(init.line, init.column, `Assigned value to variable '${init.identifier}' of type '${valueType}' does not conform to its declared type '${init.type}'.`));\n                }\n            }\n\n            init.expressionType = valueType;\n        }\n\n        symbol.type = init.expressionType;\n\n        symbolTable.add(symbol);\n    }\n\n    static typeCheckIntegerLiteral(environment, integer) {\n        integer.expressionType = Types.Int;\n    }\n\n    static typeCheckLet(environment, letExpr) {\n        environment.symbolTable.enterScope();\n\n        letExpr.initializations.forEach((init) => {\n            this.typeCheckInitialization(environment, init);\n        });\n\n        this.typeCheck(environment, letExpr.body);\n\n        letExpr.expressionType = letExpr.body.expressionType;\n\n        environment.symbolTable.exitScope();\n    }\n\n    static typeCheckNullLiteral(environment, nullExpr) {\n        nullExpr.expressionType = Types.Null;\n    }\n\n    static typeCheckProgram(environment, program) {\n        let currentClass = environment.currentClass;\n\n        program.classes.forEach((klass) => {\n            if (environment.hasClass(klass.name)) {\n                throw new Error(`Class '${klass.name}' at ${klass.line + 1}:${klass.column + 1} is already defined.`);\n            }\n\n            environment.addClass(klass);\n        });\n\n        program.classes.forEach((klass) => {\n            environment.currentClass = klass;\n\n            TypeChecker.typeCheck(environment, klass);\n        });\n\n        environment.currentClass = currentClass;\n    }\n\n    static typeCheckProperty(environment, property) {\n        let symbolTable = environment.symbolTable;\n\n        if (symbolTable.check(property.name)) {\n            throw new Error(Report.error(property.line, property.column, `An instance variable named '${property.name}' is already in scope.`));\n        }\n\n        if (property.value !== undefined) {\n            this.typeCheck(environment, property.value);\n\n            if (property.type === undefined) {\n                property.type = property.value.expressionType;\n\n            } else {\n                if (!TypesUtils.conform(property.value.expressionType, property.type, environment)) {\n                    throw new Error(Report.error(property.line, property.column, `Value of type '${property.value.expressionType}' cannot be assigned to variable '${property.name}' of type '${property.type}'.`));\n                }\n            }\n        }\n\n        symbolTable.add(new Symbol(property.name, property.type, property.line, property.column));\n    }\n\n    static typeCheckReference(environment, reference) {\n        let symbol = environment.symbolTable.find(reference.identifier);\n\n        if (symbol !== undefined) {\n            reference.expressionType = symbol.type;\n\n        } else if (environment.currentClass.hasProperty(reference.identifier)) {\n            reference.expressionType = environment.currentClass\n                .getProperty(reference.identifier)\n                .type;\n\n        } else {\n            throw new Error(Report.error(reference.line, reference.column, `Reference to an undefined identifier '${reference.identifier}'.`));\n        }\n    }\n\n    static typeCheckStringLiteral(environment, string) {\n        string.expressionType = Types.String;\n    }\n\n    static typeCheckSuperFunctionCall(environment, superCall) {\n        let currentClass = environment.currentClass;\n        environment.currentClass = environment.getClass(currentClass.superClass);\n\n        let call = new FunctionCall(undefined, superCall.functionName, superCall.args);\n        call.line = superCall.line;\n        call.column = superCall.column;\n\n        this.typeCheckFunctionCall(environment, call);\n\n        superCall.expressionType = call.expressionType;\n\n        environment.currentClass = currentClass;\n    }\n\n    static typeCheckThis(environment, thisExpr) {\n        thisExpr.expressionType = environment.currentClass.name;\n    }\n\n    static typeCheckUnaryExpression(environment, expression) {\n        let funcCall = new FunctionCall(expression.expression, 'unary_' + expression.operator, []);\n\n        funcCall.line = expression.line;\n        funcCall.column = expression.column;\n\n        this.typeCheckFunctionCall(environment, funcCall);\n\n        expression.expressionType = funcCall.expressionType;\n    }\n\n    static typeCheckWhile(environment, whileExpr) {\n        this.typeCheck(environment, whileExpr.condition);\n\n        if (whileExpr.condition.expressionType !== Types.Bool) {\n            throw new Error(Report.error(whileExpr.condition.line, whileExpr.condition.column, `Condition of a while loop evaluates to a value of type '${whileExpr.condition.expressionType}', must evaluate to a boolean value.`));\n        }\n\n        this.typeCheck(environment, whileExpr.body);\n\n        whileExpr.expressionType = Types.Unit;\n    }\n}\n"]}